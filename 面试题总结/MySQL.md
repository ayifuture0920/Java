# MySQL

## 锁

### 1. 锁的种类

- 按照**「锁的粒度」**分为：**表级锁、行级锁**

- 按照**「类型」**分为：**共享锁、排他锁**

- 按照**「思想」**分为：**乐观锁、悲观锁**


### 2.表级锁与行级锁

**「表级锁」**是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，造成锁的冲突几率大，并发性能低。MyISAM 和 InnoDB 存储引擎都支持表级锁。

**「行级锁」**是粒度最小的锁机制，开销大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。

### 3. MyISAM 和 InnoDB 存储引擎使用的锁：

- MyISAM 采用**表锁(table-level locking)**。

- InnoDB 支持**行级锁(row-level locking)和表级锁，默认为行级锁**


### 4.MYISAM存储引擎

#### 4.1 表共享读锁和表独占写锁

MyISAM中默认支持的表级锁有两种：**「表共享读锁（read lock）」**和**「表独占写锁（write lock）」**。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。

Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：

```mysql
# 显式地添加表级读锁
LOCK TABLE 表名 READ
# 显示地添加表级写锁
LOCK TABLE 表名 WRITE
# 显式地解锁（当一个事务commit的时候也会自动解锁）
unlock tables;
```

在执行select语句的时候MySQL底层会隐式地加读锁，执行增、删、改的操作时就会隐式地加写锁。

**总结：**

**「当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁」**

**「当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作」**

#### 4.2 当MyISAM存储引擎发生锁竞争时，是如何处理的？

*读者写者问题--写者优先原则*

1. MyISAM存储引擎中，**「假如同时一个读请求，一个写请求过来的话，它会优先处理写请求」**，因为MyISAM存储引擎中认为写请求比都请求重要。
2. **「假如大量的读写请求过来，就会导致读请求长时间的等待，或者"线程饿死"，因此MyISAM不适合运用于大量读写操作的场景」**，这样会导致长时间读取不到用户数据，用户体验感极差。当然可以通过设置low-priority-updates参数，设置请求链接的优先级，使得Mysql优先处理读请求。

### 5. InnoDB存储引擎

#### 5.1 InnoDB的表级锁：

MyISAM中默认支持的表级锁有两种：**「表共享读锁（read lock）」**和**「表独占写锁（write lock）」**。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。



InnoDB有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表级锁**：

- **「意向共享锁（IS）」**：事务打算给数据行加**「行共享锁（S）」**，事务在给一个数据行加共享锁前必须先取得该表的 **「IS 锁」**。与**「表共享读锁（read lock）」**兼容，与**「表独占写锁（write lock）」**互斥。

- **「意向排他锁（IX）」**：事务打算给数据行加**「行排他锁（X）」**，事务在给一个数据行加排他锁前必须先取得该表的 **「IX 锁」**。与**「表共享读锁（read lock）」**及**「表独占写锁（write lock）」**都互斥，意向锁之间不会互斥。

`意向锁是有数据引擎自己维护的，用户无法手动操作意向锁`，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

**意向锁作用**：如果另一个事务试图在该**==表级别==**上应用**「表共享读锁（read lock）」**或**「表独占写锁（write lock）」**，则受到由第一个事务控制的表级别意向锁的阻塞，第二个事务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。*（一个事务在试图对表加表级锁的时候，必须保证：a.当前没有其他事务持有该表的排他锁。b.当前没有其他事务持有该表中任意一行的排他锁 。）*。一旦事务提交了，意向共享锁、意向排他锁都会自动释放。 

==**意向锁之间是互相兼容的，意向锁不会与行级的共享 / 排他锁互斥！！！**==

|            |  IS  |  IX  | 表共享读锁 | 表独占写锁 |
| :--------: | :--: | :--: | :--------: | :--------: |
|     IS     | 兼容 | 兼容 |    兼容    |    互斥    |
|     IX     | 兼容 | 兼容 |    互斥    |    互斥    |
| 表共享读锁 | 兼容 | 互斥 |    兼容    |    互斥    |
| 表独占写锁 | 互斥 | 互斥 |    互斥    |    互斥    |

#### 5.2 InnoDB的行级锁：

==InnoDB的数据时基于索引组织的，行级锁是通过对索引上的索引项加锁来实现的，而不是对记录家的锁。==

##### 5.2.1行级锁的三种算法：

- **「记录锁（Record lock）」**：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在
  Read Committed、Repeatable Read 隔离级别下都支持

  1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为记录锁。
  2. ==InnoDB的记录锁是针对于**索引**加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。==  

  ![image-20220505021156017](https://raw.githubusercontent.com/ayifuture0920/java-study/master/pictures/image-20220505021156017.png)

- **「间隙锁（Gap lock）」**：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在 Repeatable Read 隔离级别下都支持

  ![image-20220505021227863](https://raw.githubusercontent.com/ayifuture0920/java-study/master/pictures/image-20220505021227863.png)

- **「临键锁（Next-Key Lock）」**：记录锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。
  在 Repeatable Read 隔离级别下支持 

![image-20220505021319450](https://raw.githubusercontent.com/ayifuture0920/java-study/master/pictures/image-20220505021319450.png)

##### 5.2.2行级锁的两种类型：

- **「共享锁（S）」**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁，即S之间是兼容的，S与X是互斥的。

  ```mysql
  select ... lock in share mod; #添加S锁
  ```

- **「排他锁（X）」**：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

  ```mysql
  insert/ update/ delete/ select ... for update; #添加X锁
  ```

|      |  S   |  X   |
| :--: | :--: | :--: |
|  S   | 兼容 | 互斥 |
|  X   | 互斥 | 互斥 |

#### 6.乐观锁和悲观锁

##### 6.1乐观锁和悲观锁是什么

 乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。（存在成功率低的问题）
- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。（存在性能较差的问题）

##### 6.2乐观锁和悲观锁的实现方式

1. **悲观锁**的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。

2. **乐观锁**的实现方式主要有两种：**CAS机制**和**版本号机制**

   ###### **2.1 CAS（Compare And Swap）**

   ​		即**compare and swap（比较与交换）**，是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。**CAS算法**涉及到三个操作数

   - 需要读写的内存值 V
   - 进行比较的值 A
   - 拟写入的新值 B

   当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。

   ###### 2.2 版本号机制

   ​		一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会`+1`。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
   

##### 6.3 乐观锁的缺点

*ABA 问题是乐观锁一个常见的问题*

1. **ABA 问题**

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **"ABA"问题。**

> JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2. **高竞争下的开销问题**

在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。

3. **只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。

##### 6.4两种锁的使用场景

>**简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**

1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

##### 6.5 面试官追问：乐观锁加锁吗？

（1）乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了。

（2）有时乐观锁可能与加锁操作合作，例如，MySQL在执行update时会加排它锁。但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。

---

***参考：***

*https://juejin.cn/post/6844903666332368909#heading-6*

*https://juejin.cn/post/6844904197444354062#heading-10*

*https://cloud.tencent.com/developer/article/1822612*
