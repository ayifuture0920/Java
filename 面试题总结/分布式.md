# 分布式

## 一、分布式

### 1. 什么是分布式?

==参考答案==

分布式或者说 SOA 分布式重要的就是**面向服务**，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。

### 2.  为什么要分布式?

==参考答案==

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。

## 二、分布式事务

### 1. 什么是分布式事务？  

对于分布式系统⽽⾔，需要保证分布式系统中的数据⼀致性，保证数据在子系统中始终保持⼀致，避免业务出现问题。分布式系统中对数据的操作要么⼀起
成功，要么⼀起失败，必须是⼀个整体性的事务。  

分布式事务指事务的参与者、⽀持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

简单的说，在分布式系统上⼀次⼤的操作由不同的⼩操作组成，这些⼩的
操作分布在不同的服务节点上，且属于不同的应⽤，分布式事务需要保证
这些⼩操作要么全部成功，要么全部失败。    

### 2. 有哪些典型的分布式事务场景？

#### 2.1. 跨库事务

跨库事务指的是，⼀个应⽤某个功能需要操作多个库，不同的库中存储不同的业务数据。    

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/20201102225133982.jpg" alt="img" style="zoom:67%;" />

#### 2.2. 分库分表

通常⼀个库数据量⽐较⼤或者预期未来的数据量⽐较⼤，都会进⾏⽔平拆分，也就是分库分表。 

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/20201102225150285.jpg" alt="img" style="zoom: 67%;" />

 #### 2.3. 微服务化

将一些复杂的业务拆分成不同的独⽴服务，以简化业务逻辑。

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/20201102225213956.jpg" alt="img" style="zoom:67%;" />

​    

### 2. 什么是CAP原则？

==参考答案==

CAP定理又称CAP原则，指的是在一个分布式系统中，**Consistency（一致性）**、 **Availability（可用性）**、**Partition tolerance（分区容错性）**，<font color="red">**最多只能同时三个特性中的两个，三者不可兼得。**</font>

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220717121910726.png" alt="image-20220717121910726" style="zoom:50%;" />

- **Consistency (一致性)**：

  用户访问分布式系统中的任意节点，得到的数据必须一致，这就是分布式的一致性。即更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，不能存在中间状态。  

  > 分布式一致性的 3 种级别：
  >
  > 1. **强一致性** ：时刻保证客户端得到的数据都是⼀致的，
  >    那么称之为强⼀致性。（CAP 的一致性）
  > 2. **弱一致性** ：如果允许存在部分数据不⼀致，那么就称之为弱⼀致性。  
  > 3. **最终一致性** ：如果允许存在中间状态，只要求经过⼀段时间后，数据最终是⼀致的，
  >    则称之为最终⼀致性。  
  >
  > **业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。**

- **Availability (可用性)**：

  用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。好的可用性主要是指系统能够很好地为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

- **Partition Tolerance (分区容错性)**：

  - **Partition（分区）**：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。
  - **Tolerance（容错）**：在集群出现分区时，整个系统也要持续对外提供服务

> **当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。**
>
> 1. **放弃A** 放弃可⽤性的话，则在遇到⽹络分区或其他故障时，受影响的服务需要等
>    待⼀定的时间，再此期间⽆法对外提供政策的服务，即不可⽤
>
> 2. **放弃C**
>    放弃⼀致性的话（这⾥指强⼀致），则系统⽆法保证数据保持实时的⼀致性，在数据达到最终⼀致性时，有个时间窗⼝，在时间窗⼝内，数据是不⼀致的。  
>
> 简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。

因此，**分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。** 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。



**为啥不可能选择 CA 架构呢？** 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。

选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。

另外，需要补充说明的一点是： **如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。**

### 3. BASE 理论

==参考答案==

**BASE** 是 **Basically Available（基本可用）** 、**Soft-state（软状态）** 和 **Eventually Consistent（最终一致性）** 三个短语的缩写。

BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。

- **Basically Available** **（基本可用）**：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。

- **Soft State（软状态）：**软状态指允许系统中的数据存在中间状态（**CAP 理论中的数据不一致**），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点进行数据同步时存在延时。

- **Eventually Consistent（最终一致性）**：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。

  

### 4. 分布式事务分类：柔性事务 和 刚性事务

#### 4.1 刚性事务

**刚性事务**：通常⽆业务改造，强⼀致性，原⽣⽀持回滚/隔离性，低并发，
适合短事务。

**原则：刚性事务满⾜CAP的CP理论**  

> 刚性事务指的是，要使分布式事务，达到像本地式事务⼀样，具备数据强⼀致性，从CAP来看，就是说，要达到CP状态。  

刚性事务： **XA 协议（2PC、 JTA、 JTS）**、 **3PC**，但由于**同步阻塞**，处理效率低，不适合⼤型⽹站分布式场景。  

#####  XA模型 或者 X/Open DTP模型  

**X/Open DTP(Distributed Transaction Process)** 是⼀个分布式事务模型。这个模型主要使⽤了**两段提交(2PC - Two-Phase-Commit)**来保证分布式事务的完整性。

在 X/Open DTP 模型⾥⾯，有三个⻆⾊：

- **AP: Application，应⽤程序**。也就是业务层。哪些操作属于⼀个事务，就是AP定义的。
- **TM: Transaction Manager，事务管理器**。接收AP的事务请求，对全局事务进⾏管理，管理事务分⽀状态，协调RM的处理，通知RM哪些操作属于哪些全局事务以及事务分⽀等等。这个也是整个事务调度模型的核⼼部分。
- **RM: Resource Manager，资源管理器**。⼀般是数据库，也可以是其他的资源管理器，即Redis，MQ，⽂件系统等。

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/20210709140731779.png" alt="img" style="zoom:67%;" />



**XA 规范** 主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接⼝。 **XA 接⼝**是双向的系统接⼝，在 TM 以及⼀个或多个 RM 之间形成通信桥梁，从⽽在多个数据库资源下保证 **ACID** 四个特性。    

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/20210708142634430.png" alt="img" style="zoom:67%;" />

> **AP⾃⼰操作TM，当需要事务时， AP向TM请求发起事务， TM负责整**
> **个事务的提交，回滚等。**  



> 什么是 XA ？
>
> ⽤⾮常官⽅的话来说:
>
> - XA 规范 是 X/Open 组织定义的分布式事务处理（DTP， Distributed
>   Transaction Processing）标准。
>
> - XA 规范 描述了 TM 与 RM 之间的接⼝。
>   XA规范 的⽬的是允许的多个 RM（如DB，应⽤服务器，MQ
>   等）在同⼀事务中访问，这样可以使 ACID 属性跨越应⽤程序⽽保持有效。
>
> - XA 规范 使⽤两阶段提交（2PC， Two-Phase Commit）协议来保证所有资源同时提交或回滚任何特定的事务。
>
> - XA 规范 在上世纪 90 年代初就被提出。⽬前，⼏乎所有主流的数据库
>   都对 XA 规范 提供了⽀持。  
>
>   ###### a. **2PC/3PC协议**
>
>   两阶段提交（2PC）协议是XA规范定义的 数据⼀致性协议。
>
>   三阶段提交（3PC）协议对 2PC协议的⼀种扩展。  
>
>   ###### b. **JTA 规范**
>
>   作为 Java 平台上事务规范  **JTA（Java Transaction API）**也定义了对 XA 事务
>   的⽀持，实际上， JTA 是基于 XA 架构上建模的，在 JTA  中，事务管理器抽象为 `javax.transaction.TransactionManager` 接⼝，并通过底层事务服务
>   （即 JTS ）实现。像很多其他的 Java 规范⼀样， JTA 仅仅定义了接⼝，具体的实现则是由供应商(如J2EE⼚商)负责提供，⽬前JTA的实现主要由以下⼏种：
>
>   1. J2EE容器所提供的 JTA 实现(JBoss)
>   2. 2.独⽴的JTA实现:如 JOTM， Atomikos。这些实现可以应⽤在那些不使⽤ J2EE 应⽤服务器的环境⾥⽤以提供分布式事务保证。如Tomcat, Jetty以及普通的java应⽤。
>
>   ###### c. **JTS 规范**
>
>   事务是编程中必不可少的⼀项内容，基于此，为了规范事务开发， Java增
>   加了关于事务的规范，即 JTA 和 JTS 定义了⼀套接⼝，其中约定了⼏种主要的⻆⾊：
>   TransactionManager、 UserTransaction、 Transaction、 XAResource，并
>   定义了这些⻆⾊之间需要遵守的规范，如Transaction的委托给
>   TransactionManager等。  

#### 4.2 柔性事务

**柔性事务**：与刚性事务相⽐，柔性事务的特点为：有业务改造，最终⼀致性，实现补偿接⼝，实现资源锁定接⼝，⾼并发，适合⻓事务。 

> 不要求强⼀致性，⽽是要求最终⼀致性，允许有中间状态，也就是 BASE 理论。

**柔性事务满⾜ BASE 理论（基本可⽤，最终⼀致）**    

柔型事务： **TCC/FMT**、 **Saga（状态机模式、 Aop模式）**、**本地事务消息**、**消息事务（半消息）**  

### 5. 2PC（标准XA模型）（适合单体架构，很少用，了解）
**2PC** 即 **Two-Phase Commit**，⼆阶段提交 

- 阶段⼀：**提交事务请求**
- 阶段⼆：**执⾏事务提交**  

如果阶段⼀超时或者出现异常， 2PC的阶段⼆：中断事务  

**2PC**
⼴泛应⽤在数据库领域，为了使得基于分布式架构的所有节点可以在进⾏事务处理时能够保持原⼦性和⼀致性。绝⼤部分关系型数据库，都是基于
2PC完成分布式的事务处理。

#### 阶段⼀：提交事务请求

1. **事务询问**：协调者向所有参与者发送事务内容，询问是否可以执⾏提交操作，并开始等待各参与者进⾏响应；
2. **执⾏事务**：各参与者节点，执⾏事务操作，并将 Undo 和 Redo 操作计⼊本机事务⽇志；
3. 各参与者向协调者反馈事务问询的响应。成功执⾏返回 Yes，否则返回
   No。

#### 阶段⼆：执⾏事务提交

协调者在阶段⼆决定是否最终执⾏事务提交操作。这⼀阶段包含两种情形：

##### 执⾏事务

所有参与者reply Yes，那么执⾏事务提交。

1. **发送提交请求**：协调者向所有参与者发送 Commit 请求；
2. **事务提交**：参与者收到 Commit 请求后，会正式执⾏事务提交操作，并在完成提交操作之后，释放在整个事务执⾏期间占⽤的资源；
3. **反馈事务提交结果**：参与者在完成事务提交后，向协调者发送 Ack 消息
   确认；
4. **完成事务**：协调者在收到所有参与者的Ack后，完成事务。 

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/692462-20190407131001597-1193625164.png" alt="img" style="zoom: 33%;" />

##### 中断事务
事情总会出现意外，当存在某⼀参与者向协调者发送 No 响应，或者等待超时。协调者只要⽆法收到所有参与者的 Yes 响应，就会中断事务。

1. **发送回滚请求**：协调者向所有参与者发送 Rollback 请求；
2. **回滚**：参与者收到请求后，利⽤本机 Undo 信息，执⾏ Rollback 操作。并在回滚结束后释放该事务所占⽤的系统资源；
3. **反馈回滚结果**：参与者在完成回滚操作后，向协调者发送 Ack 消息；
4. **中断事务**：协调者收到所有参与者的回滚 Ack 消息后，完成事务中断。  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/692462-20190407131017854-1201369651.png" alt="img" style="zoom: 33%;" />

### 6. 3PC（了解）  

针对2PC的缺点，研究者提出了 3PC，即**Three-Phase Commit**。
作为 2PC 的改进版， 3PC 将原有的两阶段过程，重新划分为**CanCommit**、
**PreCommit** 和 **doCommit** 三个阶段。  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/692462-20190407142856081-1418301502.png" alt="img" style="zoom:50%;" />

#### 阶段⼀： CanCommit

1. **事务询问**：协调者向所有参与者发送包含事务内容的 canCommit 的请求，询问是否可以执⾏事务提交，并等待应答；
2. **各参与者反馈事务询问**：正常情况下，如果参与者认为可以顺利执⾏事务，则返回Yes，否则返回No。

#### 阶段⼆： PreCommit

在本阶段，协调者会根据上⼀阶段的反馈情况来决定是否可以执⾏事务的
PreCommit操作。有以下两种可能：

##### 执⾏事务预提交

1. **发送预提交请求**：协调者向所有节点发出PreCommit请求，并进⼊
   prepared阶段；
2. **事务预提交**：参与者收到PreCommit请求后，会执⾏事务操作，并将
   Undo和Redo⽇志写⼊本机事务⽇志；
3. 各参与者成功执⾏事务操作，同时将反馈以Ack响应形式发送给协调
   者，同事等待最终的Commit或Abort指令。

##### 中断事务

加⼊任意⼀个参与者向协调者发送No响应，或者等待超时，协调者在没有
得到所有参与者响应时，即可以中断事务：

1. **发送中断请求**： 协调者向所有参与者发送Abort请求；
2. **中断事务**：⽆论是收到协调者的Abort请求，还是等待协调者请求过程
   中出现超时，参与者都会中断事务；

#### 阶段三： doCommit

在这个阶段，会真正的进⾏事务提交，同样存在两种可能。

##### 执⾏提交

1. **发送提交请求**：假如协调者收到了所有参与者的Ack响应，那么将从预提交转换到提交状态，并向所有参与者，发送doCommit请求；
2. **事务提交**：参与者收到doCommit请求后，会正式执⾏事务提交操作，
   并在完成提交操作后释放占⽤资源；
3. **反馈事务提交结果**：参与者将在完成事务提交后，向协调者发送Ack消
   息；
4. **完成事务**：协调者接收到所有参与者的Ack消息后，完成事务。

##### 中断事务

在该阶段，假设正常状态的协调者接收到任⼀个参与者发送的No响应，或
在超时时间内，仍旧没收到反馈消息，就会中断事务：

1. **发送中断请求**：协调者向所有的参与者发送abort请求；
2. **事务回滚**：参与者收到abort请求后，会利⽤阶段⼆中的Undo消息执⾏
   事务回滚，并在完成回滚后释放占⽤资源；
3. **反馈事务回滚结果**：参与者在完成回滚后向协调者发送Ack消息；
4. **中断事务**：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。  

### 7. 分布式事务开源框架 Seata 

Seata 是⼀款开源的分布式事务解决⽅案，致⼒于在微服务架构下提供⾼性能和简单易⽤的分布式事务服务。 



Seata 分三⼤模块 :

- **TC** ：**Transaction Coordinator（事务协调者）**。维护全局事务和分支事务的状态，协调全局事务提交或回滚。
- **TM**：**Transaction Manager（事务管理者）**。定义全局事务的范围，开始全局事务、提交或回滚全局事务。
- **RM**：**Resource Manager（资源管理者）**。管理每个分⽀事务的资源（DB，MQ、文件系统等），每⼀个 RM 都会作为⼀个分⽀事务注册在 TC。  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220719193951920.png" alt="image-20220719193951920" style="zoom:67%;" />

Seata 为⽤户提供了 **XA** 、 **AT**、
**TCC** 和 **SAGA** 事务模式：

- **XA** 模式：**强一致性**、分阶段（2PC）事务模式，牺牲了一定的可用性，无业务侵入
- **AT** 模式：**最终一致性**的分阶段事务模式，**无业务侵入**，也<u>是 Seata 的默认模式</u>
- **TCC** 模式：**最终一致性**的分阶段事务模式，**有业务侵入**
- **SAGA** 模式：长事务模式，有业务侵入

#### 7.1 XA 模式

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220719232542244.png" alt="image-20220719232542244" style="zoom:67%;" />

##### 7.1.1 执行流程：

**TM 一阶段**的工作：

① 开始并注册全局事务到 TC

② 调用分支事务

**RM 一阶段**的工作：

① 注册分支事务到 TC

② 执行分支业务 sql 但**不提交**（意味着不释放 DB 锁）

③ 报告执行状态到 TC

**TM 二阶段**的共作：

① 通知TC事务结束

**TC 二阶段**的工作：

① TC 检测各分支事务执行状态

​	a. 如果都成功，通知所有RM提交事务

​	b. 如果有失败，通知所有RM回滚事务

**RM 二阶段**的工作：

① 接收 TC 指令，提交或回滚事务

##### 7.2.2 优缺点

XA模式的优点是什么？

- 事务的**强一致性**，满足 ACID 原则。
- 常用数据库都支持，实现简单，并且**没有代码侵入**

XA模式的缺点是什么？

- 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差
- 依赖关系型数据库实现事务

#### 7.2 AT 模式

**AT 模式** 是指 **Automatic（Branch）Transaction Mode**⾃动化分⽀事务。Seata AT 模式是增强型 **2PC 模式**，或者说是增强型的 XA 模型。

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220719225923676.png" alt="image-20220719225923676" style="zoom: 67%;" />

##### 7.2.1 执行流程

**阶段一 RM** 的工作：

- 注册分支事务
- **记录 undo-log（数据快照）**
- 执行业务 sql 并**提交**（释放 DB 锁）
- 报告事务状态

**阶段二提交时 RM** 的工作：

- 删除 undo-log 即可

**阶段二回滚时 RM** 的工作：

- 根据 undo-log 恢复数据到更新前

##### 7.2.2 脏写问题

RM 和 TC 之间是有⻓连接的，如果是正常全局提交，则 TC 通知多个 RM
异步清理掉本地的 redo log 和 undo log 即可。如果是回滚，则TC 通知每个 RM 回滚数据即可。



这⾥就会引出⼀个问题，由于本地事务都是⾃⼰直接提交了，后⾯如何回滚？由于我们在操作本地业务的前后，记录了 undo 和 redo log，因此可以通过 undo log 进⾏回滚。
由于undo log 和 redo log 和业务操作在同⼀个事务中，因此肯定会同时成功或同时失败。
但是还会存在⼀个问题，因为每个事务从本地提交到通知回滚这段时间
⾥，可能这条数据已经被别的事务修改，如果直接⽤undo log回滚，会导致数据不⼀致的情况。  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220720003610330.png" alt="image-20220720003610330" style="zoom: 50%;" />

解决思路就是引入了全局锁的概念。在释放 DB 锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20210724181843029.png" alt="image-20210724181843029" style="zoom:50%;" />

##### 7.2.3 优缺点

AT模式的优点：

- 一阶段完成直接提交事务，释放数据库资源，性能比较好
- 利用全局锁实现读写隔离
- 没有代码侵入，框架自动完成回滚和提交

AT模式的缺点：

- 两阶段之间属于软状态，属于最终一致
- 框架的快照功能会影响性能，但比 XA 模式要好很多

#### 7.3 TCC 模式

##### 7.3.1 执行流程

TCC 模式与 AT 模式非常相似，每阶段都是独立事务，不同的是 TCC 通过人工编码来实现数据恢复。需要实现三个方法：

- **Try**：资源的检测和**预留**； 
- **Confirm**：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。
- **Cancel**：预留资源释放，可以理解为 Try 的反向操作。

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220720011850994.png" alt="image-20220720011850994" style="zoom: 67%;" />

###### 1. 第⼀阶段 Try

以账户服务为例，当下订单时要扣减⽤户账户⾦额：  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/6223e8be682d613f39e5a27587635f73.png" alt="img" style="zoom: 67%;" />

假如⽤户购买 100 元商品，要扣减 100 元。
TCC 事务⾸先对这100元的扣减⾦额进⾏预留，或者说是先冻结这100元：  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/29586d0d5b4a08e27f784a80a450e9a5.png" alt="img" style="zoom:67%;" />

###### 2. 第⼆阶段 Confirm
如果第⼀阶段能够顺利完成，那么说明 “扣减⾦额” 业务(分⽀事务)最终肯定
是可以成功的。当全局事务提交时，TC 会控制当前分⽀事务进⾏提交，如果提交失败， TC 会反复尝试，直到提交成功为⽌。  

当全局事务提交时，不过之前可用金额已经扣减过了，这里只要清除冻结金额就好了：

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/6227e7939dc860283ea799abcdccbe2b.png" alt="img" style="zoom:67%;" />

###### 3. 第⼆阶段 Cancel
如果全局事务回滚，就把冻结的⾦额进⾏解冻，恢复到以前的状态， TC 会
控制当前分⽀事务回滚，如果回滚失败， TC 会反复尝试，直到回滚完成为
⽌。  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/ea3d9416a1db9998241c160b67078c51.png" alt="img" style="zoom:67%;" />

##### 7.3.2 TCC 模式和 AT 模式的区别

**AT** 和 **TCC** 都是 **2PC** 的模型。  

- ⼀阶段 prepare ⾏为

- ⼆阶段 commit 或 rollback ⾏为  

**AT 模式**

基于 **⽀持本地 ACID 事务 的 关系型数据库**：

- ⼀阶段 prepare ⾏为：在本地事务中，⼀并提交业务数据更新和相应回
  滚⽇志记录。

- ⼆阶段 commit ⾏为：⻢上成功结束， ⾃动异步批量清理回滚⽇志。

​	   ⼆阶段 rollback ⾏为：通过回滚⽇志， ⾃动⽣成补偿操作，完成数据
回滚。

**TCC 模式**

**不依赖于底层数据资源的事务⽀持**：

- ⼀阶段 prepare ⾏为：调⽤ ⾃定义 的 prepare 逻辑。

- ⼆阶段 commit ⾏为：调⽤ ⾃定义 的 commit 逻辑。

​       ⼆阶段 rollback ⾏为：调⽤ ⾃定义 的 rollback 逻辑。  

##### 7.3.3 事务悬挂和空回滚

###### 1）空回滚

当某分支事务的 Try 阶段**阻塞**时，可能导致全局事务**超时**而触发二阶段的 cancel 操作。在未执行 Try 操作时先执行了cancel操作，这时cancel不能做回滚，就是**空回滚**。

如图：

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20210724183426891.png" alt="image-20210724183426891" style="zoom: 67%;" />

执行cancel操作时，应当判断 Try 是否已经执行，如果尚未执行，则应该空回滚。

###### 2）业务悬挂

对于已经空回滚的业务，之前被阻塞的 Try 操作恢复，继续执行 Try，就永远不可能 confirm 或 cancel ，事务一直处于中间状态，这就是**业务悬挂**。

执行 Try 操作时，应当判断 cancel 是否已经执行过了，如果已经执行，应当阻止空回滚后的 Try 操作，避免悬挂

##### 7.3.4 优缺点

TCC的优点是什么？

- 一阶段完成直接提交事务，释放数据库资源，性能好
- 相比 AT 模型，无需生成快照，无需使用全局锁，性能最强
- 不依赖数据库事务，而是依赖 **补偿操作**，可以用于 **非事务型数据库**

TCC的缺点是什么？

- 有代码侵入，需要人为编写 try、Confirm 和 Cancel 接口，太麻烦
- 软状态，事务是最终一致
- 需要考虑 Confirm 和 Cancel 的失败情况，做好**幂等处理**

#### 7.4 Saga 模式

##### 7.4.1 执行流程

Saga 模式是 Seata 提供的**⻓事务**解决⽅案，在Saga模式中，业务流程中
每个参与者都提交本地事务，当出现某⼀个参与者失败则补偿前⾯已经成
功的参与者，⼀阶段正向服务和⼆阶段补偿服务都由业务开发实现。  

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20220720025721594.png" alt="image-20220720025721594" style="zoom: 67%;" />

Saga也分为两个阶段：

- 一阶段：直接提交本地事务
- 二阶段：成功则**什么都不做**；失败则通过**编写补偿业务来回滚**

##### 7.4.2 优缺点

优点：

- 事务参与者可以基于**事件驱动**实现异步调用，吞吐高
- 一阶段直接提交事务，无锁，性能好
- 不用编写TCC中的三个阶段，实现简单

缺点：

- 软状态持续时间不确定，时效性差
- 没有锁，没有事务隔离，会有脏写

#### 7.5. 四种模式对比

- 一致性：能否保证事务的一致性？强一致还是最终一致？
- 隔离性：事务之间的隔离性如何？
- 代码侵入：是否需要对业务代码改造？
- 性能：有无性能损耗？
- 场景：常见的业务场景

<img src="https://raw.githubusercontent.com/ayifuture0920/Img/main/pictures/image-20210724185021819.png" alt="image-20210724185021819" style="zoom: 50%;" />

> **AT 和 TCC 都是 最终一致性**

### 8. 如何解决分布式事务问题的？  

**Seata AT**模式和**Seata TCC**是在⽣产中最常⽤。  

- **强⼀致性场景**

对于那些特别严格的场景，可能需要⽤到Seata XA 或者 Seata AT 模式来保证强⼀致性；

如电商交易中的订单、库存和支付服务，严格要求数据绝对不能错  ，需要保证强一致性，可以使⽤成熟的如中间件Seata XA模式。  

- **弱⼀致性场景**

对于数据⼀致性要求没有那些特别严格，但对性能要求较高，且有非关系型数据库要参与的事务的场景，可以使⽤Seata TCC 保障弱⼀致性⽅案；

准备好例⼦：⼀个不是严格对数据⼀致性要求、或者由不同系统执⾏⼦事
务的场景，如电商订单⽀付服务，更新订单状态，发送成功⽀付成功消息，只需要保障弱⼀致性即可。  

- **最终⼀致性场景**

基于可靠消息的最终⼀致性，各个⼦事务可以较⻓时间内异步，但数据绝
对不能丢的场景。可以使⽤Seata AT 或者 Seata TCC 模式。  比如积分服务：增加积分； 会计服务：⽣成会计记录  

## 三、zookeeper

分布式集群工作情况下，属于多JVM的工作环境，跨JVM之间已经无通过多线程的锁解决同步问题，那么就需要一种更加高级的锁机制——**分布式锁**，是用来**处理跨机器的进程之间的数据同步问题**

### 1. 分布式锁的实现

- 基于缓存实现分布式锁：**`Redis`、`Memcache`** 

- zookeeper实现分布式锁：**`Curator`**
- 数据库层面实现分布式锁：悲观锁、乐观锁

### 2. `ZooKeeper`分布式锁原理

![image-20220522105804539](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220522105804539.png)

**核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。**

1.客户端获取锁时，在lock节点下创建临时顺序节点。

2.然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。

3.如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。

4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。



**为什么要创建临时顺序节点？**

临时：防止客户端宕机导致锁无法被释放

顺序：方便查找lock下最小的子节点

### 3. 谈下你对 Zookeeper 的认识？

`ZooKeeper` 是一个分布式的，开源分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

`ZooKeeper` 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

`Zookeeper`保证了如下分布式一致性特性：

- 顺序一致性
- 原子性
- 单一视图
- 可靠性
- 实时性（最终一致性）

### 4. Zookeeper 都有哪些功能？

- **集群管理**：监控节点存活状态、运行请求等；
- **主节点选举**：主节点挂掉了之后可以从备用的节点开始新一轮选举，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；
- **分布式锁**：`Zookeeper` 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。`Zookeeper` 可以对分布式锁进行控制。
-  **命名服务**：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。

### 5. 谈下你对 ZAB 协议的了解？

`ZAB (Zookeeper Atomic Broadcast)` 协议是`Zookeeper` 专门设计的一种支持崩溃恢复的**原子广播协议**。这个协议保证了分布式事务的最终一致性（主从节点的状态同步）。`ZAB` 协议包括两种基本的模式：**崩溃恢复**和**消息广播**。



**崩溃恢复**：当整个 `Zookeeper` 集群刚刚启动或者`Leader`服务器宕机、重启或者网络故障导致不存在过半的服务器与 `Leader` 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 `Leader` 服务器，然后集群中 `Follower` 服务器开始与新的 `Leader` 服务器进行数据同步。当集群中超过半数机器与该 `Leader` 服务器完成数据同步之后，退出恢复模式进入消息广播模式。

**消息广播**：类似一个两阶段提交过程，针对客户端的事务请求， `Leader` 服务器会为其生成对应的事务 `Proposal`，并将其发送给集群中的其余所有机器，再分别收集各自的选票，最后进行事务提交。


### 6. Zookeeper 有几种部署模式？

Zookeeper 有三种部署模式：

- 单机部署：一台集群上运行；

- 集群部署：多台集群运行；

- 伪集群部署：一台集群启动多个 `Zookeeper` 实例运行。


### 7. Zookeeper提供了什么？

**文件系统** 和 **通知机制**

#### 7.1 Zookeeper文件系统

Zookeeper提供一个多层级的节点命名空间（节点称为`ZNode`）。与普通文件系统不同的是，这些节点都可以设置关联的数据，而普通文件系统中只有文件节点可以存放数据而目录节点不行。 `Zookeeper`为了保证高吞吐率和低延迟，在内存中维护了这个树状的目录结构，这种特性使得`Zookeeper`不能用于存放大量的数据，每个节点的存放数据上限为1M。

#### 7.2 Zookeeper 通知机制

Client 端会对某个 `ZNode` 建立一个 **watcher** 事件，当该 `ZNode` 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 `ZNode` 变化来做出业务上的改变等。

### 8.zookeeper  集群中的角色

| 角色 | 描述                                                         |
| :-----------------: | :----------------------------------------------------------- |
|  领导者（Leader）  | 领导者负责进行投票的发起和决议，更新系统状态                 |
| 跟随者（Follower） | Follower用于接收客户请求并向客户端返回结果，在选主过程中进行投票 |
| 观察者（Observer） | Observer可以接收客户端连接，将写请求转发给Leader节点，但Observer不参加选票过程，只同步Leader的状态。Observer的目的是为了扩展系统，提高读取速度。 |

所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器叫：Leader 服务器。其他的服务器被称为 Follower 服务器。Leader 服务器将客户端事务请求转化成一个事务 Proposal（提议），并将改 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 服务器接收了正确的反馈后，那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求将前一个 Proposal 提交。

- **Leader** ：负责整个Zookeeper 集群工作机制中的核心，主要工作有以下两个：

  a. 事务请求的唯一调度和处理者，保证集群事务处理的顺序性

  b. 集群内部各服务器的调度者

- **Follower** ：它是 Leader 的追随者，其主要工作有三个：

  a. 处理客户端的非事务请求，转发事务请求给 Leader 服务器

  b. 参与事务请求 Proposal 的投票

  c. 参与 Leader 选举投票

- **Observer** ：是 zookeeper 自 3.3.0 开始引入的一个角色，它不参与事务请求 Proposal 的投票，也不参与 Leader 选举投票，只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。

### 9. 四种类型的数据节点 `ZNode`

（1）**PERSISTENT-持久节点**

除非手动删除，否则节点一直存在于 Zookeeper 上

（2）**EPHEMERAL-临时节点**

临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。

（3）**PERSISTENT_SEQUENTIAL-持久化顺序节点**

基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

（4）**EPHEMERAL_SEQUENTIAL-临时顺序节点**

基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

### 10. 集群中为什么要有主节点？

在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 Leader 选举。

### 11. 集群中有 3 台服务器，其中1个节点宕机，这个时候 Zookeeper 还可以使用吗？. 

可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。

集群规则为 2N+1 台，N >0，即最少需要 3 台。

### 12. Zookeeper 宕机如何处理？

Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。

Zookeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 Zookeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以：

3 个节点的 Cluster 可以挂掉 1 个节点(leader 可以得到 2 票 > 1.5)

2 个节点的 Cluster 就不能挂掉任何1个节点了(leader 可以得到 1 票 <= 1)

### 13. Zookeeper 和 Dubbo 的关系？

#### 13.1 zookeeper的作用：

zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的 ip 和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向 zookeeper 注册服务，服务的提供者多了能服务的客户就多了。

#### 13.2 Dubbo：

是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，Dubbo提供一个框架解决这个问题。
注意这里的Dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的（如 Redis ），只是大家都用zk。

#### 13.3 zookeeper和Dubbo的关系：

Dubbo 将注册中心进行抽象，它可以外接不同的存储媒介给注册中心提供服务，有 zookeeper ，Memcached，Redis 等。

引入了 zookeeper 作为存储媒介，也就把 zookeeper 的特性引进来。

- 首先是**负载均衡**，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 zookeeper 集群配合相应的 Web 应用就可以很容易达到负载均衡；
- **资源同步**，单单有负载均衡还不够，节点之间的数据和资源需要同步，zookeeper 集群就天然具备有这样的功能；
- **命名服务**，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向 zookeeper 上的指定节点 /dubbo/${serviceName}/providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/31/16e219bc770098df~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

## 四、Dubbo

## RPC

### 1. 何为RPC？

**RPC（Remote Procedure Call）** 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。

**为什么要 RPC ？** 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。

**RPC 能帮助我们做什么呢？** 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。

举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。

一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

### 2. RPC 的原理是什么?

我们可以将整个 RPC的 核心功能看作是下面👇5 个部分实现的：

1. **客户端（Service Consumer）** ：调用远程方法的一端。
2. **客户端 Stub（桩）** ： 这其实就是一代理类。代理类主要做的事情很简单，就是把需要调用的方法、类、方法参数等信息传递到服务端。
3. **网络传输** ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。
4. **服务端 Stub（桩）** ：这个桩就不是代理类了。*我觉得理解为桩实际不太好，大家注意一下就好。*这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端 的类。
5. **服务端（Service Provider）** ：提供远程方法的一端。

具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。

![RPC原理图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg)

1. 客户端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用请求后负责将方法、参数等进行**序列化**：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息**反序列化**为Java对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并对其进行**序列化**：`RpcResponse`，发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息**反序列化**为Java对象:`RpcResponse` ，这样也就得到了最终结果。

---

## Dubbo架构

### 1. Dubbo 架构中的核心角色有哪些？

[**Apache Dubbo**](https://github.com/apache/dubbo) |ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC 框架。

![dubbo-relation](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/源码/dubbo/dubbo-relation.jpg)

- **Container：** 服务运行容器，负责加载、运行服务提供者。必须。
- **Provider：** 提供服务的服务提供方，会向注册中心注册自己提供的服务。必须。
- **Consumer：** 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。
- **Registry：** 服务注册中心。注册中心会返回服务提供者的地址列表给消费者。非必须。
- **Monitor：** 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。

### 2. 注册中心

#### 注册中心的作用了解么？

注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在**启动时**与注册中心交互。

#### 注册中心挂了，服务是否可以正常访问？

可以，因为dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。当服务提供者地址发生变化时，注册中心会通知服务消费者。

#### 服务提供者宕机后，注册中心会做什么？

注册中心会立即推送事件通知消费者。

####  监控中心的作用呢？

监控中心负责统计各服务调用次数，调用时间等。

#### 注册中心和监控中心都宕机的话，服务都会挂掉吗？

不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。

### 3. Dubbo的负载均衡策略

#### 什么是负载均衡？

我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。

#### Dubbo 提供的负载均衡策略有哪些？

在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 `random` 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。

在 Dubbo 中，所有负载均衡实现类均继承自 `AbstractLoadBalance`，该类实现了 `LoadBalance` 接口，并封装了一些公共的逻辑。

`AbstractLoadBalance` 的实现类有下面这些：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220521112233094.png" alt="image-20220521112233094" style="zoom:150%;" />

- **RandomLoadBalance**

根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。

- **LeastActiveLoadBalance**

`LeastActiveLoadBalance` 直译过来就是**最小活跃数负载均衡**。**Dubbo 认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。**如果有多个服务提供者的活跃数相等就再走一遍 `RandomLoadBalance` 。

- **ConsistentHashLoadBalance**

在分库分表、各种集群中就经常使用这个负载均衡策略。

`ConsistentHashLoadBalance` 即**一致性Hash负载均衡策略**。 `ConsistentHashLoadBalance` 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。

另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。

- **RoundRobinLoadBalance**

**加权轮询负载均衡**。轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。

### 4. 集群容错

集群容错模式：

- Failover Cluster：失败重试。默认值。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操
- Failfast Cluster ：快速失败，只发起一次调用，失败立即报错。通常用于写操作。
- Failsafe Cluster ：失败安全，出现异常时，直接忽略。返回一个空结果。
- Failback Cluster ：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
- Forking Cluster ：并行调用多个服务器，只要一个成功即返回。
- Broadcast  Cluster ：广播调用所有提供者，逐个调用，任意一台报错则报错。

### 5. Dubbo 中的 Invoker 概念了解么？

简单来说，`Invoker` 就是 Dubbo 对远程调用的抽象。

![dubbo_rpc_invoke.jpg](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/dubbo_rpc_invoke.jpg)

按照 Dubbo 官方的话来说，`Invoker` 分为

- **服务提供 `Invoker`**
- **服务消费 `Invoker`**

假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节！我们屏蔽掉的这些细节就依赖对应的 `Invoker` 实现， `Invoker` 实现了真正的远程服务调用

